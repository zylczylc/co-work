************************************************************************************
别问白痴问题
我在xxx的时候遇到了xxx的错误. 这个错误可以通过以下步骤重现: (描述具体的现象)
1. 我的系统版本是xxx, 相关的工具版本是xxx
2. 我做了xxx (必要的时候贴个图)
3. 然后xxx (必要的时候贴个图)
...
为了排查这个错误, 我进行了以下尝试: (说明我很希望可以解决问题, 真的没办法才提问的)
1. 我做了xxx, 出现了xxx的结果 (必要的时候贴个图)
2. 我还做了xxx, 出现了xxx的结果 (必要的时候贴个图)
...
最后问题还没有解决, 请问我还需要做哪些事情?
***********************************************************************************
文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar
文件检索 - cat, more, less, head, tail, file, find
输入输出控制 - 重定向, 管道, tee, xargs
文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr
正则表达式
系统监控 - jobs, ps, top, kill, free, dmesg, lsof
	alias 别名 unalias 删除别名
***********************************************************************************
vim的命令模式	
	 i：当前位置输入	a：当前之后输入	   I：当前行开头输入	
     A：当前行尾输入	o：当前下一行输入  O：当前上一行输入
	$n:接收数据的，$0是获取当前shell脚本的名字，10以上的要带{} #获取所有输入参数个数，还有#@ #*，这俩是获取所有输入参数，不用“”：#*/#@=$1$2···$n,用“”：$*是拼接，$@是一个一个独立的，用于循环打印
	循环：for(循环变量)···in 和 do···done	
	$?:获取上一个shell命令的状态，”一般“0成功，非0失败
	$$:获取当前shell的id进程号,,不太会用
	export:全局环境变量
	unset :清除环境变量
	/etc/profile.d/里面的.sh好像在开机都会执行
	echo $0:bash是非登陆环境，-bash是登陆环境,直接输入bash也可以切换为非登陆环境
	字符串三种格式：
	a='adf'		纯原样输出，拼接不能用，也就是不能嵌套		
	a=“adf” 	可以用于拼接嵌套，双引号嵌套是”\"嵌套内容\"“
	a=adf		不能加空格，其他和“”一样
	${#字符串变量名}	输出字符串长度
	字符串拼接：
			1无符号直接拼接
			2双引号拼接		双引号最常用
			3混合拼接，就是都混合的使用
	字符串截取：
			${被截取变量名:start:length} 就是第几个开始截止到第几个
			${被截名:start}	左边开始截至尾
			${被截名:0-start:length}	从右侧开始截，截几个
			${被截名#*被查找字符}	从左开始，找到第一个被查找字符开始截取以面的所有
			${被截名##*被查找字符}	左开始找作后出现的被查字，截之后的所有
			${被截名%被查找字符*}	我想你能明白吧
			${被截名%%被查找字符*}	豆腐三碗三碗豆腐
	数组：（只支持一维数组,打印输出不能直接输出一整个数组）
		变量名=(a b c d ···)
		变量名=([下标号]=a [下标号]=c [下标号]=b) 可以乱序存储
	数组拼接：（括号括起来就行）
		变量合=(${变量1[*]} ${变量2[*]})	*换@一样的，但是前后要保持样
	删除数组：
		unset 变量名[n]	里面的n就是想要删除的第几个数
	命令设置别名：（命令只是临时的，真想删除要去文件里）
				alias 别名="命令"	单双引号都行
				unalias 别名		这是删除
				unalias -a			是删除所有
	echo相关的信息：
				echo -n(代表不换行) -e（可以解析到/n/c等转义字符）
	read相关的信息：如果read后面啥都不加，输入直就存进￥REPLY里了
				read [-options] 要存储的变量名
				read -n(读取几个字符) -p（显示提示信息）-s（不显示输入）-t（输入超时时间，超时显示非0退出状态）
	判断语句：
			if [] then ···else ···fi
	退出语句：
			exit  有一个返回码“0”，0-255为失败退出
	设置变量declare:
				declare [+-][aArxif] 变量名称=值		
							+取消变量所设属性
							-指定变量属性 
								a：普通索引数组
								A：key-value关联数组
								r：只读
								x：全局变量
								i：整型
								f：函数变量
				declare -a 数组名(数1 数2···)
				declare -A 数组名（["one"]=value ["two"]=value ）
	expr语句：
		只能整数运算：expr 1 +-*/% 1 	会输出值,乘要转义\*
		整数比较运算：
			[value1 -eq value2]	是否相等，等了返回0,否则1
					-ne（不相等）、-gt（大于、-lt（小于）、-ge（大于等于）、-le（小于等于）
			(($a>$b))	> < >= <= == != 是这样的格式，也是只能整数
		字符串比较：（用[]时要转义比较符号，用[[]]转不转都行）
			[ $a \> $b ]  ==或=（这俩一样的） \>  \<  -z(检测字符串长度是否为0,0返回true) -n(检测长度是否不为0,返回true) $(检测是否为空，不空返回true)
			[[$a > $b]]	==或= > < >= <=
		布尔运算：
			[! 表达式] 结果取反
			[表达式1 -o 表达式2]	或运算
			[表达式1 -a 表达式2]	与运算
	逻辑运算：





*************************************************************************************
-----------------
Git学习记录
-----------------
*************************************************************************************
Git基础命令：
		1. clone			git上面的克隆到本地
		2. checkout			本地检出一个分支进行修订
		3. add				提交前将代码交到暂存区
		4. commit			提交到本地仓库,加-m可以写注释
		5. fetch			git上的仓库抓取到本地，不进行修改的那种
		6. pull				git上远程拉取到本地仓库，自动合并放在工作区，相当于fetch+merge
		7. push				修改后，需要和团队共享代码时，将代码上传到github上
		8. git init			创建一个.git的本地仓库
		9. log				查看日志,--graph（图形化显示）
		10.reset --hard ID	ID可以用log查询，但是最好不要用
		11.branch			查看、添加分支 -d（删除分支）-D（强制删除）-vv(查看连接关系)
		12.chechout			切换分支 -b可以直接创建切换
		13.merge			合并分支
		14.status			查看状态
		15.push				上传github
		16.diff				查看修改内容
		ssh-keygen -t rsa	配置密钥，都直接回车
		
		创建一个.gitingore的文件，里面说一句*. 关键字	，所有.关键字的文件都不会被add的
	远程链接方法：
		git remote add origin github仓库的ssh地址
		git push --set-upstream origin hub一个分支名	创建链接，下次推直接对应那个分支



明天设置以下git log 的快捷方式 --abbrev-commit （显示前7位数）
git log --all --graph --decorate

************************************************************************************
-------------------
GDB学习记录 （本系统自带GDB貌似）
-------------------
************************************************************************************
	RTFM：https://sourceware.org/gdb/current/onlinedocs/gdb.html/
	检查gdb是否安装成功：
				gdb --version
	gcc -g .c文件 之后就可以gdb打开:
								b\break:打断点，可以是函数名，亦可是行号 
								info ：查看信息的，比如info b（查看断点）
								n 	：断点处继续执行
								q 	：退出
								p 	：打印变量值 &变量为变量地址
								list：查看代码
								s	：进具体的某个函数
								set logging on ：输出记录日志
								whatpoint:*变量地址 ：可以跟踪这个变量地址，info查看有哪些跟踪
								ulimit -a 、ulimit -c unlimit 这个不知道为啥生成不了core文件
								gdb -p 后台进程ID ：可以调试正在运行的后台程序
								
	gdb里面还可以写shell：
				shell ll、cat之类的

************************************************************************************
________________
gcc学习记录
————————————————
************************************************************************************
	查看版本：gcc -v 或 g++ -v
			gcc 需要加-lstdc++才能链接标准C++库，g++ 直接就可以
	文件后缀：
		.c(源文件) .i(预处理) .s(编译后的汇编) .o(二进制可执行文件)
	简介操作：
		gcc 文件名.o -o 可执行文件名
		
		gcc后缀：
			-E（进行预处理，生成.i) 
			-S（进行汇编，生成.s) 
			-c（进行可执行文件，生成.o) 
			-o（指定生成文件名）
			-I（指定头文件地址）
			-D（编译时定义一个宏定义）
			-l（指定使用的库，名称要掐头去尾lib“xxx”.a,只输入xxx）
			-L（指定搜索库的路径）
	静态库和动态库：
		静态库：lib***.a 的格式
			相关命令：
				ar -c（强行创建一个库）-s（创建索引，加快库的创建）-r（在库中添加新的.o程序，有同名的替换，没有的末尾加）静态库名字 .o文件
			完整静态库制作流程：
				1 写一个.c文件，包含需要的函数，然后写一个.h文件，里面定义了刚刚所有的函数名。
				2 gcc -c 刚写的.c文件 生成.o文件，
				3 ar -rsc libXXX.a 刚生成的.o文件
				4 main.c就可以引用头文件了
					gcc main.c -o 可执行文件名 -L 头文件地址 -l 头文件名
				5 可以运行了	

		动态库：lib***.so的格式
			相关命令：
				gcc -c *.c -fpic/-FPIC 
				gcc -shared *.o -o libxxx.so
		使用动态库可能出现找不到动态库的问题，解决方法：
				1 改环境变量：给$LD_LIBRARY_PATH添加上动态库的位置（在根目录的.bashrc文件中）

				2 在/etc/ld.so.conf 文件中添加动态库的绝对地址,之后sudo ldconfig
				3 创建软链接，放在/lib/或者/usr/lib中
					sudo ln -s 当前位置 /lib/或者/usr/lib 位置
***********************************************************************************
--------------
makefile的编写
--------------
***********************************************************************************
	格式：
可执行文件名称：*.c 
`Tab`gcc相关命令eg：gcc -c *.c -o 可执行文件名称
		内部预定义变量：
				AR = ar
				AS = as
				CC = gcc/cc
				CPP= c语言预编译器名称
				CXX= g++
				FC = f77
				RM = rm -f
				%  = * 通配符
			自动变量：
				$* ：目标文件名称，不包括扩展名
				$+ ：所有依赖文件
				$< ：依赖项中第一个依赖文件名称
				$? ：依赖项中，所有比目标文件时间戳晚的依赖文件，互相以空格隔开
				$@ ：目标文件的名称，包含扩展名
				$^ ：依赖项中，所有不重复的依赖文件，空格隔开
				.PHONY ：伪目标
			等号：
				 = ：就普通赋值
				:= ：定义后就不能再更改
				?= ：如果已经定义了就不再定义，尚未定义的就定义一下
				+= ：追加
				\  ：续行符号
		内置函数：
			wildrard 搜索位置···
			指定某个目录，搜索路径下指定类型的文件，返回值是地址路径加文件名
			patsubst 原先后缀 更改后缀 有哪些文件要变（可以用一个存储好的变量代替）	
			改变文件后缀的
			subst ：字符串转化为函数
			foreach：循环函数
			foreach <var>,<list>,<text>把list中的元素逐一取出，执行text表达式
